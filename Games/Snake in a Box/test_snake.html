<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Generation Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #222;
      color: #fff;
    }
    #testGrid {
      display: inline-grid;
      gap: 2px;
      margin: 20px 0;
    }
    .test-tile {
      width: 40px;
      height: 40px;
      border: 1px solid #666;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      background: #333;
    }
    .test-tile.head { background: #ff6b6b; font-weight: bold; }
    .test-tile.tail { background: #4a90e2; font-weight: bold; }
    .test-tile.body { background: #4caf50; }
    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      margin: 10px 5px;
    }
    #info {
      margin: 20px 0;
      padding: 10px;
      background: #333;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <h1>Snake Path Generation Test</h1>
  <div id="info">
    <p>Grid Size: <span id="gridSize">5x5</span></p>
    <p>Snake Length: <span id="snakeLength">0</span></p>
    <p>Coverage: <span id="coverage">0%</span></p>
  </div>
  <button onclick="testSnake(5)">Test 5x5</button>
  <button onclick="testSnake(6)">Test 6x6</button>
  <button onclick="testSnake(7)">Test 7x7</button>
  <div id="testGrid"></div>
  <div id="pathInfo"></div>

  <script>
    function testSnake(size) {
      const grid = generateSnakePath(size);
      displayGrid(grid, size);
    }

    function generateSnakePath(gridSize) {
      const totalTiles = gridSize * gridSize;
      let row = Math.floor(Math.random() * gridSize);
      let col = Math.floor(Math.random() * gridSize);
      
      let snakePath = [{ row, col }];
      const visited = new Set();
      visited.add(`${row},${col}`);
      
      let attempts = 0;
      const maxAttempts = 10000;
      
      while (snakePath.length < totalTiles && attempts < maxAttempts) {
        attempts++;
        
        const neighbors = [
          { row: row - 1, col },
          { row: row + 1, col },
          { row, col: col - 1 },
          { row, col: col + 1 }
        ].filter(n => 
          n.row >= 0 && n.row < gridSize && 
          n.col >= 0 && n.col < gridSize && 
          !visited.has(`${n.row},${n.col}`)
        );
        
        if (neighbors.length === 0) {
          if (snakePath.length < totalTiles) {
            row = Math.floor(Math.random() * gridSize);
            col = Math.floor(Math.random() * gridSize);
            snakePath = [{ row, col }];
            visited.clear();
            visited.add(`${row},${col}`);
            continue;
          }
          break;
        }
        
        const scoredNeighbors = neighbors.map(n => {
          const futureNeighbors = [
            { row: n.row - 1, col: n.col },
            { row: n.row + 1, col: n.col },
            { row: n.row, col: n.col - 1 },
            { row: n.row, col: n.col + 1 }
          ].filter(fn => 
            fn.row >= 0 && fn.row < gridSize && 
            fn.col >= 0 && fn.col < gridSize && 
            !visited.has(`${fn.row},${fn.col}`)
          );
          return { neighbor: n, score: futureNeighbors.length };
        });
        
        scoredNeighbors.sort((a, b) => b.score - a.score);
        const topCandidates = scoredNeighbors.filter(sn => sn.score >= scoredNeighbors[0].score - 1);
        const next = topCandidates[Math.floor(Math.random() * topCandidates.length)].neighbor;
        
        snakePath.push({ row: next.row, col: next.col });
        visited.add(`${next.row},${next.col}`);
        row = next.row;
        col = next.col;
      }
      
      return snakePath;
    }

    function displayGrid(snakePath, gridSize) {
      const gridEl = document.getElementById('testGrid');
      gridEl.style.gridTemplateColumns = `repeat(${gridSize}, 40px)`;
      gridEl.innerHTML = '';
      
      const grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(null));
      
      snakePath.forEach((segment, index) => {
        grid[segment.row][segment.col] = index;
      });
      
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          const tile = document.createElement('div');
          tile.className = 'test-tile';
          
          if (grid[r][c] !== null) {
            const index = grid[r][c];
            if (index === 0) {
              tile.className += ' head';
              tile.textContent = 'H';
            } else if (index === snakePath.length - 1) {
              tile.className += ' tail';
              tile.textContent = 'T';
            } else {
              tile.className += ' body';
              tile.textContent = index;
            }
          } else {
            tile.textContent = '?';
          }
          
          gridEl.appendChild(tile);
        }
      }
      
      const totalTiles = gridSize * gridSize;
      const coverage = (snakePath.length / totalTiles * 100).toFixed(1);
      
      document.getElementById('gridSize').textContent = `${gridSize}x${gridSize}`;
      document.getElementById('snakeLength').textContent = snakePath.length;
      document.getElementById('coverage').textContent = `${coverage}%`;
      
      const pathInfo = document.getElementById('pathInfo');
      pathInfo.innerHTML = `<h3>Path Details:</h3><p>${snakePath.map((s, i) => `${i}: (${s.row},${s.col})`).join(', ')}</p>`;
    }

    // Auto-test on load
    testSnake(5);
  </script>
</body>
</html>